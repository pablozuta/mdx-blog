---
title: React OpenCLassRooms Course 
tags:
  - react
  - javascript
  - courses
date: 31-01-2023
---
## Understand the Purpose of React.js
The goal of using frameworks is to avoid reinventing the wheel to solveÂ common problems that developers face when scaling or growing a web application. Examples include management of the user interface, user events, the DOM, and forms. Moreover, initializing a codebase with a framework simplifies things when starting out and when integrating new people into the codebase.

Frameworks also provide applications withÂ **modularity**. In other words, they allow you to build your user interface fromÂ **components**. A component encompasses all of theÂ **HTML, JS, and CSS**Â tailored toÂ a specific needÂ and can beÂ **reused**Â inÂ other user interfaces.

### Why React?
- Availability
- Community
- Professional Opportunities

React doesnâ€™t directly manipulate the browser DOM. Instead,Â it generates aÂ **virtual DOM**, separate from the browser DOM. When needed, itÂ **reconciles**Â the virtual DOM with the browser DOM, carefully minimizing necessary operations.Â It allows forÂ **optimum performance**, meaning React can be usedÂ **in various contexts**Â and not only within the browser, usually in native mobile apps, etc.

**Weâ€™re going to be working together to create aÂ website for a plant shop: Jungle House!**

## 3-Write Modular Code With Components in JSX
**THINK IN COMPONENTS**
**components are fundamental to React**.
Every interface is made up of different elements: buttons, lists, headings, sub-headings. Altogether, these elements make up aÂ **user interface**, orÂ **UI**.
With React, each of these reusable parts is a component. They contain everything they need to function correctly:Â **structure, styles, and behavior**Â (e.g., an action triggered when clicked).
Components mean you can **reuse the same data structure**, filling it out with different datasets.
Therefore, it is every React developerâ€™s mission to split each user interface into reusable elements, all nested within one another. Most components are created byÂ **combining other, simpler ones**.
**DISCOVER JSX**
JSX is a JavaScript extension created by React, which means you can use syntax in the form of tags directly in the JavaScript code.

```jsx
function Header() {
    return (<div>
        <h1>Jungle House</h1>
    </div>)
}
```
Â It's aÂ **special feature of React**: unlike other frameworks where you write enriched HTML, React teams have created JSX, their own JavaScript-based syntax that allows you toÂ **mix HTML and JS**.
Â 
Letâ€™s go back to the Â `<Header />`Â  component. Itâ€™s looking a bit lonely up there!

Letâ€™s add aÂ  Â `<Description />`Â  component:
```jsx
function Description() {
    return (<p>The place to buy all the plants you've ever wanted ğŸŒµğŸŒ±ğŸ</p>)
}
```
two components must always beÂ **wrapped in a single parent component**.
React wants you toÂ **reuse components**. Therefore, you must structure your interface in component trees.Â Â 

Letâ€™s group Header and Description together in a banner:
```jsx
function Banner() {
    return (
    <div>
        <Header />
        <Description />
    </div>
}
```
#### Manipulate Data Within JSX Components
In React, curly bracesÂ Â `{`Â  andÂ `}`Â  are also useful. Use them whenever youâ€™re working with JavaScript expressions.

TheyÂ allow you toÂ **apply JavaScript expressions**Â directly to JSX for:
```jsx
<div>
The answer to life, the universe, and everything is 
{ 6 * 7 }
</div>

<div>{ alexia.toUpperCase() }</div>

<div>{ 2 > 0 ? 'Two is greater than zero' : 'This will never appear }</div>

<div>{ myTitle }</div>
	
<div>{ 42 }</div>
```
For example, ifÂ you put a description text into a variable:
```jsx
function Description() {
    const text = "The place to buy all the plants you've ever wanted"
    return (<p>{ text }</p>)
}
```
You can apply a JavaScript function on top of this, and put a few emojis afterwards:
```jsx
function Description() {
    const text = "The place to buy all the plants you've ever wanted"
    const emojis = "ğŸ¤‘ğŸ¤‘ğŸ¤‘"
    return (<p>{text.slice(0, 11) + emojis}</p>)
}
```
#### Give it a go
-   **Reuse the Â `Banner`Â  component from this chapter**Â displaying the name of our shop. Output the heading in a JavaScript variable:Â it should initially be written lowercase and then transformed to uppercase with JavaScript.Â 
    
-   **Create a**Â `**<Cart />**`Â **component**Â to appear underÂ the heading.
    
-   **The cart contains three plants**: monstera, ivy, and a bunch of flowers.
    
-   **Create three variables**Â for the plant prices: theÂ monstera costs 8â‚¬, the ivy costs 10â‚¬, and the bunch of flowers costs 15â‚¬. (We'll assume a European market and thus use euros for the currency, but feel free to use your country's currency in your own application!)
    
-   **The cart contains a list (**`**<ul>**`**)**, and each element has the name of the item and the price.Â 
    
-   **The cart total**Â adds up the three prices.

See where it saysÂ Â `export default`Â  ? This is a syntax provided in ES6, which means you donâ€™t have to use curly braces when importing.
[Webpack](https://webpack.js.org/)Â makes importing a component easy withÂ  Â `import`Â .Â This tool is essential for linking files together so that the browser can interpret them.

## Incorporate Style and Assets in Your Project
how do we attribute style with a CSS class?

All you need to do is use theÂ **`className`**Â attribute and specify a string. Itâ€™s possible to use several classes on one element by placing them one after the other, separated by a space.Â 

Under Â `/src`Â ,Â  weâ€™ll create a Â `/styles`Â  folder for CSS files.Â  Letâ€™s drag in Â `index.css`Â  , but without forgetting to modify the relevant path to import Â `index.css`Â  into Â `index.js`

**Use Images**

```js
import logo from '../assets/logo.png'
import '../styles/Banner.css'
Â 
function Banner() {
    const title = 'Jungle House'
    return (
        <div className='jh-banner'>
            <img src={logo} alt='Jungle House' className='jh-logo' />
            <h1 className='jh-title'>{title}</h1>
        </div>
    )
}
Â 
export default Banner
```

## Increase Your Efficiency Using Lists and Conditional Rendering

**Loop Through your Content**
In code, youâ€™ll often find that different lists of data are structured in the same way. Great news! ğŸ¤© There's no need to strain over copying and pasting: you canÂ **just loop through your content and generate React components from it**.
The JavaScript .map() Method
```js
const numbers = [1, 2, 3, 4]
const doubles = numbers.map(x => x * 2) // [2, 4, 6, 8]
```
In our case,Â you can use it toÂ **transform a list of data**Â **into a list of components**.
```js
const plantList = [
    'Monstera',
    'Ficus Lyrata',
    'Silver Pothos',
    'Yucca',
    'Palm'
]
```
```js
function ShoppingList() {
    return (
        <ul>
            {plantList.map((plant) => (
                <li>{plant}</li>
            ))}
        </ul>
    )
}

export default ShoppingList
```
As you can see, for each entry in the array, it returns a Â `<li>`Â  element.

#### Define Your Key
`key`Â props help ReactÂ **identify which items have changed, are added, or are removed**. Keys should be given to the elements inside the array toÂ provide a stable identity.
1.  It should beÂ **unique**Â within the array.
2.  It should beÂ **stable over time**Â (the same source data should always have the same key= value).

**Using Keys**
you couldÂ **define a string and combine it with the item index**
```js
function ShoppingList() {
    return (
        <ul>
            {plantList.map((plant, index) => (
                <li key={`${plant}-${index}`}>{plant}</li>
            ))}
        </ul>
    )
}

export default ShoppingList
```
### Contextualize Component Content
React allows you to create lists of components, saving developers vast amounts of time. But thatâ€™s not all! You can also use the JSX to render elements inÂ **components conditionally**.

**Conditional Rendering**
In our list of plants Â `plantList.js`Â  , add anÂ **`isBestSale`Â  category that corresponds to a Â `boolean`**Â , which tells you whetherÂ a plant isÂ a best seller. It looks like this:
chaining conditions
```js
{
    name: 'Monstera',
    category: 'Classic',
    id: '1ed',
    isBestSale: true
},
```
Now that we have our boolean,Â let'sÂ **use a conditional to display different emojis according to whether it is a best seller or not**. In Â `ShoppingList.js`Â  , on the same level as the name, add:
```js
{plantList.map((plant) => (
    <li key={plant.id}>
        {plant.name}
        {plant.isBestSale ? <span>ğŸ”¥</span> : <span>ğŸ‘</span>}
    </li>
))}
```
On second thought, it might not work as a sales argument. ğŸ¤”Â  Instead, letâ€™s just put ğŸ”¥Â  for the best sellers and nothing for the others.

To do that,Â **return Â `null`Â  in the condition where you donâ€™t want anything to be displayed**:
```js
{plant.isBestSale ? <span>ğŸ”¥</span> : null}
```
Do you know what, though? Thereâ€™s an even easier way to write this â€“ you can use Â `&&`Â  .Â 

Placed between curly braces,`&&`Â goes before a JSX element andÂ **states that the element will only be generated if the condition is met**. SoÂ you could write:
```js
{plant.isBestSale && <span>ğŸ”¥</span>}
```
**Other Methods**
You can also chain conditions.

For example, if you wanted to display the ğŸ”¥ for the plants that are both Â `isBestSale`Â Â **and**Â in the classic category:

```js
{plant.isBestSale && plant.category === "classic" && <span>ğŸ”¥</span>}
```

Similarly, if you wanted the ğŸ”¥ to be displayed next to plants that are eitherÂ `isBestSale`Â Â **or**Â in the classic category:

```js
{plant.isBestSale || plant.category === "classic" && <span>ğŸ”¥</span>}
```
Keep your code clean, though. If you have too many conditions, remove them from what your function returns. ğŸ˜‰

## Reuse Your Components With Props
### Discover the PropsÂ Syntax
Letâ€™s go back to our plant site. Weâ€™re now going to create a new component that weâ€™ll reuse. The idea is to create a water scale and a light scale for each plant.

Weâ€™ll reopen Â `ShoppingList.js`Â andÂ **add the relevant data in Â `plantList`**:Â 

-   `water`Â  data, which corresponds to the recommended amount of water for each plant.
    
-   `light`Â  data, which corresponds to the amount of light required.
    

Starting with light, in each plant item,Â **add a**Â Â **`CareScale`Â  component to which weâ€™ll pass the value prop**:
```js
<CareScale scaleValue={plant.light} />
```
You get props from theÂ **parameters of the function**Â that defines your component.Â 

So, for Â `CareScale`Â ,Â you have:
```js
function CareScale(props) {
    const scaleValue = props.value
    return <div>{scaleValue}â˜€ï¸</div>
}

export default CareScale
```
But didnâ€™t we say we wanted a scale from 1 to 3?

To do this,Â **go for a list**, which you can create manually.

YouÂ end up with:
```js
function CareScale(props) {
    const scaleValue = props.value

    const range = [1, 2, 3]

    return (
        <div>
            {range.map((rangeElem) =>
                scaleValue >= rangeElem ? <span key={rangeElem.toString()}>â˜€ï¸</span> : null
            )}
        </div>
    )
}
```
Props areÂ objects that you get fromÂ **the parameters of your function component**.

### Create Parameters
Start byÂ **specifying aÂ Â `type`Â  Â `prop`Â  for theÂ Â `CareScale`Â component and then reuse this component**Â for both water and light:
```js
<CareScale careType='water' scaleValue={plant.water} />
<CareScale careType='light' scaleValue={plant.light} />
```
We can nowÂ **configure theÂ  CareScaleÂ  component so it can generate the data**Â for water and light:
```js
function CareScale({ scaleValue, careType }) {
    const range = [1, 2, 3]
    
    const scaleType = careType === 'light' ? 'â˜€ï¸' : 'ğŸ’§'
    
    return (
        <div>
            {range.map((rangeElem) => scaleValue >= rangeElem ? <span                      key={rangeElem.toString()}>{scaleType}</span> : null
            )}
        </div>
    )
}
```
As you can see, we usedÂ **two different syntaxes for our props**. For Â scaleTypeÂ  , we assigned a Â stringÂ  between quotes. However, we gaveÂ Â scaleValueÂ  the value of an object, which we passed between curly braces.Â 

In practice, you can give a prop any possible value in JavaScript, but syntactically, in JSX, you only have two options:

-   AÂ Â StringÂ  literal, marked by quotes.Â 
    
-   Curly braces Â `{}`Â  for everything else (boolean, number, JavaScript expression, etc.).


## Manage Data Flow From Parent to Child
So props allow you to configure your components. They respond to the React logic, according to which data descends through your tree of components in aÂ **one-way data flow**.
For props, there are two rules you have to follow:

- A parent component always passesÂ a prop to its child: this is the only normal route of transmission.
    
- A prop isÂ **read-only**Â in the component that receives it.

## Interact With Components Using Events
An event is aÂ **reaction**Â to anÂ **action**Â carried out by the user, such as clicking a button or entering text in a form.

declare a handleClick
```JSX
function handleClick() {
console.log("log this into the console")
}
```

now to call the code
```JSX
<button onClick={handleClick}>Click Me</button>
```
Let's see what it looks like when React passes the default object as a parameter to the functions indicated in the event callback:
```JSX
function handleClickEvent(e) {
console.log("this is the event: ", e)
}
```

#### Create Forms more easily with React
React simplifies form management: you can easily access the value, whether it's an input checkbox, textarea, or even a select with Â onChangeÂ  .

There are two main ways to manage forms:Â **controlled and uncontrolled**. You should deal with the uncontrolled method swiftly because it requires less involvement from React, which encourages the use of controlled forms.
#### Delegate Control Using Uncontrolled Forms
Here's aÂ **form**Â that wrapsÂ our input:
```JSX
<form onSubmit={handleSubmit}>
    <input type='text' name='my_input' defaultValue='Type your text' />
    <button type='submit'>Enter</button>
</form>
```
And forÂ Â **`handleSubmit`**, we get:
```JSX
function handleSubmit(e) {
    e.preventDefault()
    alert(e.target['my_input'].value)
}
```
Pretty simple, isnâ€™t it? Youâ€™re delegating the work to your DOM. Indeed, uncontrolled forms mean you don't have toÂ **manage too much information**. However, this approach is a bit less React, because it has its limitations.

#### Take Control of Your Forms
Let's create anÂ **`inputValue`**Â Â variable and theÂ **function**Â that we'll use to change its value in the local state with Â `useState`Â  .Â Â 

The line of code below allowsÂ us to set the initial state for Â `inputValue`Â  andÂ the corresponding function to modify it and to specify the default value "Ask your question here
```JSX
const [inputValue, setInputValue] = useState("Ask your question here")
```
WhichÂ returns aÂ `QuestionForm`:
```JSX
import { useState } from 'react'
function QuestionForm() {
    const [inputValue, setInputValue] = useState('Ask your question here')
    return (
        <div>
            <textarea
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
            />
        </div>
    )
}

export default QuestionForm
```
We passed a callback function to Â `onChange`Â  to saveÂ our input value inÂ our local state.Â We'll access the typed input value with Â `e.target.value`Â  .Â 

`inputValue`Â  now has access to the content ofÂ our input at any time. We canÂ **create a button that triggers an alert**Â to renderÂ our input content, like this:
```JSX
<div>
    <textarea
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
    />
    <button onClick={() => alert(inputValue)}>Alert me ğŸš¨</button>
</div>
```
#### Understand the Benefits of Controlled Forms


It means you canÂ **interact directly with the user's information**Â and display an error message if the data is invalid or filter the data to intercept invalid values.Â Â 

If we decide that the letter â€˜fâ€™ is not valid (an odd example, I know), we can declare the variable:
```JSX
const isInputError = inputValue.includes('f')
```


And display an error message (or not) according to this boolean:
```JSX
{isInputError && (
    <div>ğŸ”¥ You are not allowed to use the letter â€œfâ€ here.</div>
)}
```
You might not realize it just now, but this gives you great freedom as a developer in terms of the checks you want to create. Youâ€™ve got the power! ğŸ”¥

Great, I now know two methods, but when should I use controlled components and when should I use the uncontrolled version?!

Itâ€™s a case-by-case judgment. Youâ€™ll have to decide based on your constraints. When you have a quick component to do that isn't complex, uncontrolled input might be all you need. However, if you have checks to do, itâ€™s certainly better to use a controlled component. There seem to be many more controlled components in codebases.

There are also libraries that you can use to manage forms and their validation as cleanly as possible, such asÂ [the tool react-hook-form](https://react-hook-form.com/).
## Set Up Your Local State With useState
**Use Stateful Components**
**Discover the useState Hook**

## Share State Between Different Components

## Trigger Effects With useEffect
**Specify when to trigger an effect with dependecies




