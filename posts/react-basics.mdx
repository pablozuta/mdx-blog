---
title: React Basics
tags:
  - react
  - javascript
  - fundamentals 
date: 01-02-2023
---
### Before You Learn React
React apps are built using modern JavaScript features, which are commonly known as ES6.
Here are some of the JavaScript topics that you need to be comfortable with before you begin your journey learning React.

-   Data types 
-   Using var, let and const 
-   Conditionals and Loops 
-   Using objects, arrays and functions 
-   ES6 Arrow functions 
-   In-built functions such as map(), forEach() and promises. 
-   Destructuring Arrays and Objects 
-   Error Handling

**You need to be comfortable with using npm as your package manager**, since you will be using npm to install packages within your React application.  Make sure you are aware of how to do the following with npm before you get started on this course.

-   Installation command to install npm modules in your project 
-   Installing a package as a dev dependency 
-   Start command 
-   Updating npm version 
-   Navigating around the package.json file

----
### JavaScript modules, imports - exports
In JavaScript, a module is simply a file.
The purpose of a module is to have more modular code, where you can work with smaller files, and import and export them so that the apps you build are more customizable and have more composable parts.
A module can be as simple as a single function in a separate file.
Consider the following function declaration:
```js
function addTwo(a, b) {
   console.log(a + b);
}
```
Say that you have a file named **addTwo.js** that contains only the above code.
How would you make this file a JavaScript module?

#### **Module Exports**

There is more than one way to export a module in JavaScript.
In general, there are two ways to export modules in JavaScript:
1.  Using default exports 
2.  Using named exports
#### **Default Exports**

You can have **one default export** per JavaScript module.

Using the above **addTwo.js** file as an example, here are two ways to perform a default export:
```js
export default function addTwo(a, b) {
    console.log(a + b);
}
```
Here's an alternative syntax:
```js
function addTwo(a, b) {
   console.log(a + b);
}

export default addTwo;
```
### **Named Exports**

Named exports are a way to export only certain parts of a given JavaScript file.

In contrast with default exports, you can export as many items from any JavaScript file as you want.

In other words, there can be only one default export, but as many named exports as you want.

For example:
```js
export function addTwo(a, b) {
    console.log(a + b)
}

export function addThree(a, b, c) {
    console.log(a + b + c)
}
```
Here's another way you could do it
```js
function addTwo(a, b) {
    console.log(a + b)
}

function addThree(a, b, c) {
    console.log(a + b + c)
}
export {addTwo, addThree};
```
#### **Importing Modules**

Just like when exporting modules in JavaScript, there are several ways to import them.

The exact syntax depends on how the module was exported.

Say that you have two modules in a folder.

The first module is **addTwo.js** and the second module is **mathOperations.js**.

You want to import the **addTwo.js** module into the **mathOperations.js** module.
```js
import addTwo from './addTwo';
```
So, you could start this import with the import keyword, then the name under which you’ll use this imported code inside the **mathOperations.js** file. You would then type the keyword from, and finally the location of the file, _without the .js extension._

Contrast the above import of the default addTwo export with the different import syntax if the addTwo function was instead a named export:
```js
import {addTwo} from './addTwo';
```
Please note that there are **many more caveats, rules, and implementations of working with modules in JavaScript.**

---
### Dissecting Props
Recall that much like parameters in a JavaScript function which allow you to pass in values as arguments, React uses properties, or **props**, to pass data between components.
Remember first that JSX code in React is just syntactic sugar - meaning, a nicer way to write some hard-to-read code.
For example, let’s say you have a component that returns a piece of JSX:
```JSX
function App() {
   return <h1>Header App </h1>
}
```
… if you used the Babel transpiler to transpile this JSX syntactic sugar code down to plain JavaScript code, you’d get back some unusual code:
```
"use strict";
function App() {
    return /**#__PURE__*/React.createElement("h1", null, "Header App");
}
```
You just want to focus on the React.createElement("h1", null, "Hello there"); part. You can ignore the rest.

This means that the createElement function receives three arguments:

1.  The wrapping element to render. 
2.  A null value (which is there to show an absence of an expected JavaScript object value). 
3.  The inner content that will go inside the wrapping element.

Interestingly, the inner content that will go inside the wrapping element can also be a call to the createElement function.
For example, let’s say you have a slightly more complex JSX element structure:

```JSX
function App() {
return (
  <div>
  <h1>Hello there</h1>
  </div>
)
}
```
the transpiled return statement in plain JavaScript again returns two createElement functions:
```
"use strict";
function App() {
  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("h1", null, "Hello there"));

}
```
If you format this output, remove the "use strict" line, and remove the __PURE__ comments, you get a more readable output:
```JSX
function App() {
  return React.createElement(
    "div",
    null,
    React.createElement("h1", null, "Hello there")
  );
}
```
So now the third argument of the outer-most React.createElement call is another React.createElement call.
This means that a nested JSX structure is just a bunch of nested React.createElement calls, passed in to other React.createElement calls as their third argument.

#### The second – null – argument
The second argument of null can – in this case – be replaced with an empty object.
In that case, your code would contain a pair of curly braces instead of the word null:
```JSX
"use strict";
function App() {
  return React.createElement(
    "div",
    {},
    React.createElement("h1", {}, "Hello there")
  );
}
```
This object is referred to as the _props_ object. It is the main mechanism of sending data from a parent component to a child component in React.

The way this works is described in React docs using the following code:
```JSX
React.createElement(
  type,
  [props],
  [...children]
)
```
#### The third argument (...children)

This is the inner content that will go inside the wrapping element. It's what makes it possible to nest elements inside other elements, mimicking the way that HTML works.

----
### Props and Children
Previously, you learned that you could pass props to and within a component. But there is also a special prop known as props.children, which is automatically passed to every component.
To understand the concept of props.children, consider the following real-life situation: you have a couple of apples, and you have a couple of pears. You'd like to carry the apples some distance, so obviously, you'll use a bag.

It's not a "bag for apples". It's not a "bag for pairs". It's just a bag. Nothing about this bag makes it such that it needs to be referred to as a bag in which you'd only and always carry apples, nor a bag in which you'd only and always carry pears.

In a way, the bag "doesn't care" if it is used to carry apples or pears. Nothing about the bag changes. There are no changes in the bag's material, size, shape, or color - because it can handle apples or pears being carried inside of it, without issues.

Now, consider the following component:
```JSX
function Apples(props) {
  return (
    <div className="promo-section">
        <div>
            <h2>These apples are: {props.color}</h2>
            </div>
            <div>
            <h3>There are {props.number} apples.</h3>
        </div>
    </div>
  )
}

export default Apples
```
There is also a Pears component:
```JSX
function Pears(props) {
  return (
    <h2>I don't like pears, but my friend, {props.friend}, does</h2>
  )
}
```
Now, the question is this: Let's say you want to have a Bag component, which can be used to "carry" Apples or Pears. How would you do that?
This is where props.children comes in.
You can define a Bag component as follows:
```JSX
function Bag(props) {
    const bag = {
        padding: "20px",
        border: "1px solid gray",
        background: "#fff",
        margin: "20px 0"
    }

    return (
        <div style={bag}>
            {props.children}
        </div>
    )
}

export default Bag
```
So, what this does in the Bag component is: it adds a wrapping div with a specific styling, and then gives it props.children as its content.
But what is this props.children**?**
Consider a very simple example:
```JSX
<Example>
    Hello there
</Example>
```
The Hello there text is a child of the Example JSX element. The Example JSX Element above is an "invocation" of the **Example.js** file, which, in modern React, is usually a function component.
Now, did you know that this Hello there piece of text can be passed as a **named prop** when rendering the Example component?
Here's how that would look like:
```JSX
<Example children="Hello there" />
```
Ok, so, there are two ways to do it. But this is just the beginning.
What if you, say, wanted to surround the Hello there text in an h3 HTML element?
Obviously, in JSX, that is easily achievable:
```JSX
<Example children={<h3>Hello there</h3>} />
```
What if the h3 Hello there /h3 was a separate component, for example, named Hello?
In that case, you'd have to update the code like this:
```JSX
<Example children={<Hello />} />
```
You could even make the Hello component more dynamic, by giving it its own prop:
```JSX
<Example children={<Hello message="Hello there" />} />
```
So, given the **Bag**, **Apples**, and **Pears** examples from the beginning of this reading, armed with this new knowledge, how can you make it work?
Here's how you'd render the Bag component with the Apples component as its props.children:
```JSX
<Bag children={<Apples color="yellow" number="5" />} />
```
And here's how you'd render the Bag component, wrapping the Pears component:
```JSX
<Bag children={<Pears friend="Peter" />} />
```

While the above syntax might look a bit weird, it's important to understand what is happening "under the hood".
Effectively, the above syntax is the same as the two examples below.
```JSX
<Bag>
    <Apples color="yellow" number="5" />
</Bag>

<Bag>
    <Pears friend="Peter" />
</Bag>
```

You can even have multiple levels of nested JSX elements, or a single JSX element having multiple children, such as, for example:
```JSX
<Trunk>
    <Bag>
        <Apples color="yellow" number="5" />
        <Pears friend="Peter" />
    </Bag>
</Trunk>
```
So, in the above structure, there's a Trunk JSX element, inside of which is a single Bag JSX element, holding an Apples and a Pairs JSX element.
Before the end of this reading, consider this JSX element again:
```JSX
<Bag>
    <Apples color="yellow" number="5" />
</Bag>
```
What is **Apples** to **Bag** in the above code?

**In the above code,** Apples **is a prop of the** Bag **component.** To explain further, the Bag component can wrap the Apples component, **or** _**any**_ **other component**, because I used the {props.children} **syntax in the** Bag **component function declaration**. In other words, just like in the real world, when you take a bag to a grocery store, you can “wrap” a wide variety of groceries inside the bag, you can do the same thing in React: wrap a wide variety of components inside the Bag component, using the children prop to achieve this**.**

It's crucial to understand this when working with React.

Before the end of this reading, there's another important concept that you need to be aware of: _finding the right amount of modularization_. What does this mean? Imagine, for example, that you had a number of small bags, and that each bag could only carry a single apple or pear. You'd end up having to wrap each "apple" inside a "bag". That doesn't make much sense. You can think about components making your layouts modular in a similar way. You don't want to have an entire layout contained in a single component, because that would be very difficult to work with. On the flip side, if you made each HTML element in your layout a separate component, that would make it very hard to work with, although such layout would be modular. So it's all about moderation. You need to organize your layouts by splitting them into meaningful areas of the page, and then code those meaningful areas as separate components. that would constitute the right amount of modularity. To reinforce this point, It might help to think of it in terms of how a person would describe a website: there's a menu, a footer, the shopping cart, etc.

In conclusion, when you see a JSX element wrapping some other JSX element, you can easily understand that it's all just props.children in the background.

----

