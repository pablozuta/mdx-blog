---
title: React Basics
tags:
  - react
  - javascript
  - fundamentals 
date: 01-02-2023
excerpt: React is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images. React lets you combine them into reusable, nestable components. From web sites to phone apps, everything on the screen can be broken down into components. 
---
### Before You Learn React
React apps are built using modern JavaScript features, which are commonly known as ES6.
Here are some of the JavaScript topics that you need to be comfortable with before you begin your journey learning React.

-   Data typesÂ 
-   Using var, let and constÂ 
-   Conditionals and LoopsÂ 
-   Using objects, arrays and functionsÂ 
-   ES6 Arrow functionsÂ 
-   In-built functions such as map(), forEach() and promises.Â 
-   Destructuring Arrays and ObjectsÂ 
-   Error Handling

**You need to be comfortable with using npm as your package manager**, since you will be using npm to install packages within your React application.Â  Make sure you are aware of how to do the following with npm before you get started on this course.

-   Installation command to install npm modules in your projectÂ 
-   Installing a package as a dev dependencyÂ 
-   Start commandÂ 
-   Updating npm versionÂ 
-   Navigating around the package.json file

----
### JavaScript modules, imports - exports
In JavaScript, a module is simply a file.
The purpose of a module is to have more modular code, where you can work with smaller files, and import and export them so that the apps you build are more customizable and have more composable parts.
A module can be as simple as a single function in a separate file.
Consider the following function declaration:
```js
function addTwo(a, b) {
   console.log(a + b);
}
```
Say that you have a file named **addTwo.js** that contains only the above code.
How would you make this file a JavaScript module?

#### **Module Exports**

There is more than one way to export a module in JavaScript.
In general, there are two ways to export modules in JavaScript:
1.  Using default exportsÂ 
2.  Using named exports
#### **Default Exports**

You can have **one default export** per JavaScript module.

Using the above **addTwo.js** file as an example, here are two ways to perform a default export:
```js
export default function addTwo(a, b) {
    console.log(a + b);
}
```
Here's an alternative syntax:
```js
function addTwo(a, b) {
   console.log(a + b);
}

export default addTwo;
```
### **Named Exports**

Named exports are a way to export only certain parts of a given JavaScript file.

In contrast with default exports, you can export as many items from any JavaScript file as you want.

In other words, there can be only one default export, but as many named exports as you want.

For example:
```js
export function addTwo(a, b) {
    console.log(a + b)
}

export function addThree(a, b, c) {
    console.log(a + b + c)
}
```
Here's another way you could do it
```js
function addTwo(a, b) {
    console.log(a + b)
}

function addThree(a, b, c) {
    console.log(a + b + c)
}
export {addTwo, addThree};
```
#### **Importing Modules**

Just like when exporting modules in JavaScript, there are several ways to import them.

The exact syntax depends on how the module was exported.

Say that you have two modules in a folder.

The first module is **addTwo.js** and the second module is **mathOperations.js**.

You want to import the **addTwo.js** module into the **mathOperations.js** module.
```js
import addTwo from './addTwo';
```
So, you could start this import with the import keyword, then the name under which youâ€™ll use this imported code inside the **mathOperations.js** file. You would then type the keyword from, and finally the location of the file, _without the .js extension._

Contrast the above import of the default addTwo export with the different import syntax if the addTwo function was instead a named export:
```js
import {addTwo} from './addTwo';
```
Please note that there are **many more caveats, rules, and implementations of working with modules in JavaScript.**

---
### Dissecting Props
Recall that much like parameters in a JavaScript function which allow you to pass in values as arguments, React uses properties, or **props**, to pass data between components.
Remember first that JSX code in React is just syntactic sugar - meaning, a nicer way to write some hard-to-read code.
For example, letâ€™s say you have a component that returns a piece of JSX:
```JSX
function App() {
   return <h1>Header App </h1>
}
```
â€¦ if you used the Babel transpiler to transpile this JSX syntactic sugar code down to plain JavaScript code, youâ€™d get back some unusual code:
```
"use strict";
function App() {
    return /**#__PURE__*/React.createElement("h1", null, "Header App");
}
```
You just want to focus on the React.createElement("h1", null, "Hello there"); part. You can ignore the rest.

This means that the createElement function receives three arguments:

1.  The wrapping element to render.Â 
2.  A null value (which is there to show an absence of an expected JavaScript object value).Â 
3.  The inner content that will go inside the wrapping element.

Interestingly, the inner content that will go inside the wrapping element can also be a call to the createElement function.
For example, letâ€™s say you have a slightly more complex JSX element structure:

```JSX
function App() {
return (
  <div>
  <h1>Hello there</h1>
  </div>
)
}
```
the transpiled return statement in plain JavaScript again returns two createElement functions:
```
"useÂ strict";
functionÂ App()Â {
Â Â returnÂ /*#__PURE__*/React.createElement("div",Â null,Â /*#__PURE__*/React.createElement("h1",Â null,Â "HelloÂ there"));

}
```
If you format this output, remove the "use strict" line, and remove the __PURE__ comments, you get a more readable output:
```JSX
functionÂ App()Â {
Â Â returnÂ React.createElement(
Â Â Â Â "div",
Â Â Â Â null,
Â Â Â Â React.createElement("h1",Â null,Â "HelloÂ there")
Â Â );
}
```
So now the third argument of the outer-most React.createElement call is another React.createElement call.
This means that a nested JSX structure is just a bunch of nested React.createElement calls, passed in to other React.createElement calls as their third argument.

#### The second â€“ null â€“ argument
The second argument of null can â€“ in this case â€“ be replaced with an empty object.
In that case, your code would contain a pair of curly braces instead of the word null:
```JSX
"useÂ strict";
functionÂ App()Â {
Â Â returnÂ React.createElement(
Â Â Â Â "div",
Â Â Â Â {},
Â Â Â Â React.createElement("h1",Â {},Â "HelloÂ there")
Â Â );
}
```
This object is referred to as the _props_ object. It is the main mechanism of sending data from a parent component to a child component in React.

The way this works is described in React docs using the following code:
```JSX
React.createElement(
Â Â type,
Â Â [props],
Â Â [...children]
)
```
#### The third argument (...children)

This is the inner content that will go inside the wrapping element. It's what makes it possible to nest elements inside other elements, mimicking the way that HTML works.

----
### Props and Children
Previously, you learned that you could pass props to and within a component. But there is also a special prop known as props.children, which is automatically passed to every component.
To understand the concept of props.children, consider the following real-life situation: you have a couple of apples, and you have a couple of pears. You'd like to carry the apples some distance, so obviously, you'll use a bag.

It's not a "bag for apples". It's not a "bag for pairs". It's just a bag. Nothing about this bag makes it such that it needs to be referred to as a bag in which you'd only and always carry apples, nor a bag in which you'd only and always carry pears.

In a way, the bag "doesn't care" if it is used to carry apples or pears. Nothing about the bag changes. There are no changes in the bag's material, size, shape, or color - because it can handle apples or pears being carried inside of it, without issues.

Now, consider the following component:
```JSX
functionÂ Apples(props)Â {
Â Â returnÂ (
Â Â Â Â <divÂ className="promo-section">
Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â <h2>TheseÂ applesÂ are:Â {props.color}</h2>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â <h3>ThereÂ areÂ {props.number}Â apples.</h3>
Â Â Â Â Â Â Â Â </div>
Â Â Â Â </div>
Â Â )
}

exportÂ defaultÂ Apples
```
There is also a Pears component:
```JSX
functionÂ Pears(props)Â {
Â Â returnÂ (
Â Â Â Â <h2>IÂ don'tÂ likeÂ pears,Â butÂ myÂ friend,Â {props.friend},Â does</h2>
Â Â )
}
```
Now, the question is this: Let's say you want to have a Bag component, which can be used to "carry" Apples or Pears. How would you do that?
This is where props.children comes in.
You can define a Bag component as follows:
```JSX
functionÂ Bag(props)Â {
Â Â Â Â constÂ bagÂ =Â {
Â Â Â Â Â Â Â Â padding:Â "20px",
Â Â Â Â Â Â Â Â border:Â "1pxÂ solidÂ gray",
Â Â Â Â Â Â Â Â background:Â "#fff",
Â Â Â Â Â Â Â Â margin:Â "20pxÂ 0"
Â Â Â Â }

Â Â Â Â returnÂ (
Â Â Â Â Â Â Â Â <divÂ style={bag}>
Â Â Â Â Â Â Â Â Â Â Â Â {props.children}
Â Â Â Â Â Â Â Â </div>
Â Â Â Â )
}

exportÂ defaultÂ Bag
```
So, what this does in the Bag component is: it adds a wrapping div with a specific styling, and then gives it props.children as its content.
But what is this props.children**?**
Consider a very simple example:
```JSX
<Example>
Â Â Â Â HelloÂ there
</Example>
```
The Hello there text is a child of the Example JSX element. The Example JSX Element above is an "invocation" of the **Example.js** file, which, in modern React, is usually a function component.
Now, did you know that this Hello there piece of text can be passed as a **named prop** when rendering the Example component?
Here's how that would look like:
```JSX
<ExampleÂ children="HelloÂ there"Â />
```
Ok, so, there are two ways to do it. But this is just the beginning.
What if you, say, wanted to surround the Hello there text in an h3 HTML element?
Obviously, in JSX, that is easily achievable:
```JSX
<ExampleÂ children={<h3>HelloÂ there</h3>}Â />
```
What if the h3 Hello there /h3 was a separate component, for example, named Hello?
In that case, you'd have to update the code like this:
```JSX
<ExampleÂ children={<HelloÂ />}Â />
```
You could even make the Hello component more dynamic, by giving it its own prop:
```JSX
<ExampleÂ children={<HelloÂ message="HelloÂ there"Â />}Â />
```
So, given the **Bag**, **Apples**, and **Pears** examples from the beginning of this reading, armed with this new knowledge, how can you make it work?
Here's how you'd render the Bag component with the Apples component as its props.children:
```JSX
<BagÂ children={<ApplesÂ color="yellow"Â number="5"Â />}Â />
```
And here's how you'd render the Bag component, wrapping the Pears component:
```JSX
<BagÂ children={<PearsÂ friend="Peter"Â />}Â />
```

While the above syntax might look a bit weird, it's important to understand what is happening "under the hood".
Effectively, the above syntax is the same as the two examples below.
```JSX
<Bag>
Â Â Â Â <ApplesÂ color="yellow"Â number="5"Â />
</Bag>

<Bag>
Â Â Â Â <PearsÂ friend="Peter"Â />
</Bag>
```

You can even have multiple levels of nested JSX elements, or a single JSX element having multiple children, such as, for example:
```JSX
<Trunk>
Â Â Â Â <Bag>
Â Â Â Â Â Â Â Â <ApplesÂ color="yellow"Â number="5"Â />
Â Â Â Â Â Â Â Â <PearsÂ friend="Peter"Â />
Â Â Â Â </Bag>
</Trunk>
```
So, in the above structure, there's a Trunk JSX element, inside of which is a single Bag JSX element, holding an Apples and a Pairs JSX element.
Before the end of this reading, consider this JSX element again:
```JSX
<Bag>
Â Â Â Â <ApplesÂ color="yellow"Â number="5"Â />
</Bag>
```
What is **Apples** to **Bag** in the above code?

**In the above code,** Apples **is a prop of the** Bag **component.** To explain further, the Bag component can wrap the Apples component, **or** _**any**_ **other component**, because I used the {props.children} **syntax in the** Bag **component function declaration**. In other words, just like in the real world, when you take a bag to a grocery store, you can â€œwrapâ€ a wide variety of groceries inside the bag, you can do the same thing in React: wrap a wide variety of components inside the Bag component, using the children prop to achieve this**.**

It's crucial to understand this when working with React.

Before the end of this reading, there's another important concept that you need to be aware of: _finding the right amount of modularization_. What does this mean? Imagine, for example, that you had a number of small bags, and that each bag could only carry a single apple or pear. You'd end up having to wrap each "apple" inside a "bag". That doesn't make much sense. You can think about components making your layouts modular in a similar way. You don't want to have an entire layout contained in a single component, because that would be very difficult to work with. On the flip side, if you made each HTML element in your layout a separate component, that would make it very hard to work with, although such layout would be modular. So it's all about moderation. You need to organize your layouts by splitting them into meaningful areas of the page, and then code those meaningful areas as separate components. that would constitute the right amount of modularity. To reinforce this point, It might help to think of it in terms of how a person would describe a website: there's a menu, a footer, the shopping cart, etc.

In conclusion, when you see a JSX element wrapping some other JSX element, you can easily understand that it's all just props.children in the background.


----
### Styling JSX elements
There are various ways to style JSX elements.
Probably the simplest way to do this is using the link HTML element in the head of the **index.html** file in which your React app will mount.
The href attribute loads some CSS styles, probably with some CSS classes, and then, inside the function component's declarations, you can access those CSS classes using the className attribute.

```JSX
function Promo(props) {
    return (
    <divÂ className="promo-section">
Â Â Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <h1>{props.heading}</h1>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <h2>{props.promoSubHeading}</h2>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â </div>
     
    );
}
export default Promo;
```
In CSS:
```CSS
.promo-sectionÂ {
Â Â Â Â font-weight:Â bold;
Â Â Â Â line-height:Â 20px;
}
```

Another way to add CSS styles to components is using inline styles.
The syntax of inline styles in JSX is a bit custom.
Consider a starting Promo component, containing code that you encountered earlier:
```JSX
function Promo(props) {
    return(
    Â <divÂ className="promo-section">
Â Â Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <h1>{props.heading}</h1>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <h2>{props.promoSubHeading}</h2>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â </div>
    );
}
export default Promo;
```
Now you can add some inline styles to it:
```JSX
function Promo(props) {
    return(
    Â <divÂ className="promo-section">
Â Â Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <h1 style={{color:"tomato", fontSize:"40px", fontWeight:"bold"}}>{props.heading}</h1>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <h2>{props.promoSubHeading}</h2>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â </div>
    );
}
export default Promo;
```
So, there's nothing special about this object, except for the fact that youâ€™ve inlined it and placed it inside a pair of curly braces. Additionally, since it's just JavaScript, those CSS properties that would be hyphenated in plain CSS, such as, for example, font-size:40px, become camelCased, and the value is a string, making it look like this: fontSize:"40px".
Besides inlining a _style object literal_, you can also save it in a variable, and then use that variable instead of passing an object literal.
That gives you an updated Promo component, with the styles object saved as a JavaScript variable:

```JSX
function Promo(props) {

const styles = {
    color: "tomato",
    fontSize: "40px"
}

return (
        Â <divÂ className="promo-section">
Â Â Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <h1Â style={styles}>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {props.heading}
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â </h1>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <h2>{props.promoSubHeading}</h2>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â </div>
);
}
```
Using this approach makes your components more self-contained, because they come with their own styles built-in, **but it also makes them a bit harder to maintain.**

----
### JSX syntax and the arrow function

**Components as function Expressions**
Up to this point, youâ€™ve likely only observed ES5 function declarations used to define components in React. However, this is not the only way to do it.

**Function Expressions**
Letâ€™s start with a function declaration used as a component in React:
```JSX
function Nav(props) {
    return (
    Â Â <ul>
Â Â Â Â Â Â Â Â Â Â Â Â <li>{props.first}</li>
Â Â Â Â Â Â Â Â </ul>
    )
}
```
This component's code returns a list item containing the value of the â€˜firstâ€™ prop.
Now, let's change this function declaration to a function expression:
```JSX
const Nav = function(props) {
    return (
    <ul>
Â Â Â Â Â Â Â Â Â Â Â Â <li>{props.first}</li>
Â Â Â Â Â Â Â Â </ul>
    )
}
```
The component is, for the most part, the same. The only thing that's changed is that youâ€™re now using an anonymous (nameless) function, and assigning this anonymous function declaration to a variable declared using the const keyword, and the name Nav. The rest of the code is identical.
Changing a component from a function declaration to a function expression doesn't change its behavior, or how you write the code to render the Nav component. It's still the same:
```JSX
<Nav first="Home" />
```
You can also take this concept a step further, using arrow functions.

**Components as Arrow Functions**

Arrow functions are a core feature of the ES6 version of JavaScript.
One of the main benefits of using arrow functions is its shorter syntax.
Consider the Nav function expression written as an arrow function:
```JSX
const Nav = (props) => {
    return (
    Â <ul>
Â Â Â Â Â Â Â Â Â Â Â Â <li>{props.first}</li>
Â Â Â Â Â Â Â Â </ul>
    )
}
```
So, the way to think about this is the following:
-   The arrow itself can be thought of as the replacement for the function keyword.Â 
-   The parameters that this arrow function accepts are listed before the arrow itself.Â 

To reiterate, take the smallest possible **anonymous ES5 function**:
```JSX
cons example = function() {}
```
And then observe how this is written as an arrow function:
```JSX
const example = () => {}
```
Another important rule regarding arrow functions is that **using the parentheses is optional if there's a single parameter that a function accepts**.
In other words, another correct way to write the previous Nav arrow function component would be to drop the parentheses around â€˜propsâ€™:
```JSX
constÂ NavÂ =Â propsÂ =>Â {
Â Â Â Â returnÂ (
Â Â Â Â Â Â Â Â <ul>
Â Â Â Â Â Â Â Â Â Â Â Â <li>{props.first}</li>
Â Â Â Â Â Â Â Â </ul>
Â Â Â Â )
}
```
Another interesting thing about arrow functions is the **implicit return**. However, it only works if it's on the same line of code as the arrow itself. In other words, the implicit return works if your entire component is a single line of code.
To demonstrate how this works, letâ€™s re-write the Nav component as a one-liner:
```JSX
const Nav = () => <ul><li>Home</li></ul>
```
Note that with the implicit return, you don't even have to use the curly braces that are compulsory function body delimiters in all other cases.

### Using Arrow Functions in Other Situations
In React, just like in plain JavaScript, arrow functions can be used in many different situations. One such situation is using it with, for example, the forEach() built-in array method.
For example:
```JSX
[10, 20, 30].forEach(item => item * 10)
```
The output of the above vanilla JavaScript line of code would be three number values:
```
100
200
300
```
You could also write this code in ES5 syntax:
```JSX
[10, 20, 30, 40].forEach(function(item) {
        return item * 10
    }
)
```
Both these functions perform the exact same task. Only the syntax is different. The ES6 function is a lot shorter because:
-   The arrow function has a single parameter, so you do not need to add parentheses around the item parameter (to the left of the arrow)Â 
-   Since the arrow function fits on one line of code, you donâ€™t need to use curly braces around the function body, or the return keyword; it's implicitÂ 

Arrow functions are used extensively in JSX in React, and getting used to their syntax and being able to "mentally parse" it as you read it is an important skill to have and helps you get better at writing React apps.


----
### Ternary operators and functions in JSX
**A different way of writing an if...else conditional**

You are likely familiar with the structure of an if...else conditional. Here is a quick refresher:
```JSX
let name = 'Bob';
if (name == 'Bob') {
    console.log('Hello, Bob')
  } else {
    console.log('Hello, Friend')
  }
```
The above code works as follows:

1.  First, I declare a name variable and set it to a string of "Bob".
2.  Next, I use the if statement to check if the value of the name variable is "Bob". If it is, I want to console.log the word "Bob".
3.  Otherwise, if the name variable's value is not "Bob", the else block will execute and output the words "Hello, Friend" in the console.
    

Above, I gave you an example of using an if...else conditional. Did you know that there is another, different way, to effectively do the same thing? It's known as the **ternary operator**. A ternary operator in JavaScript uses two distict characters: the first oneis **the question mark**, that is, the ? character. To the left of the ? character, you put _a condition that you'd like to check for_. Just like I did in the above if...else statement, the condition I'm checking is name == 'Bob'. In other words, I'm asking the JavaScript engine to look at the value that's stored inside the name variable, and to verify if that value is the same as 'Bob'. If it is, then the JavaScript engine will return the boolean value of true. If the value of the name variable is something different from 'Bob', the value that the JavaScript engine returns will be the boolean value of false.

Here is the code that reflects the explanation in the previous paragraph:
```JSX
name == 'Bob' ?
```
Note that the above code is incompleted. I have the condition that I'm checking (the name == 'Bob' part). I also have the ? character, that is, the first of the two characters needed to construct a syntactically valid ternary operator. However, I still need the second character, which is the colon, that is the : character. This character is placed after the question mark character. I can now expand my code to include this as well:
```JSX
nameÂ ==Â 'Bob'Â ?Â :
```
This brings me a step closer to completing my ternary operator. Although I've added the characters needed to construct the ternary operator, I still need to add the return values. In other words, if name == 'Bob' evaluates to true, I want to return the words, "Yes, it is Bob!". Otherwise, I want to return the words "I don't know this person".
```JSX
name == 'Bob' ? 'Yes, it is Bob': "I don't know this person"
```
This, in essence, is how the ternary operator works. It's just some shorthand syntax that I can use as a replacement for the if statement. To prove that this is really the case, here's my starting if...else example, written as a ternary operator:
```JSX
letÂ nameÂ =Â 'Bob';

nameÂ ==Â 'Bob'Â ?Â console.log('Hello,Â Bob')Â :Â console.log('Hello,Â Friend');
```
### Using ternary expressions in JSX
Letâ€™s examine an example of a component which uses a ternary expression to randomly change the text that is displayed.
```JSX
function Example() {
    return (
    <div className="heading">
    <h1>{Math.random() >= 0.5? "Over 0.5": "Under 0.5"}</h1>
    </div>
    )
}
```
Inside the <h1 element, the curly braces signal to React that you want it to parse the code inside as regular JavaScript.

Then, inside the curly braces, you can add a ternary statement. Every ternary statement conceptually, expressed in pseudo-code, works like this:
```JSX
comparison? true: false
```
## Using function calls in JSX
Another way to work with an expression in JSX is to invoke a function. Function invocation is an expression because every expression returns a value, and function invocation will always return a value, even when that return value is undefined.

Like the previous example, you can use function invocation inside JSX to return a random number:
```JSX
functionÂ Example2()Â {
Â Â Â Â returnÂ (
Â Â Â Â Â Â Â Â <divÂ className="heading">
Â Â Â Â Â Â Â Â Â Â Â Â <h1>Here'sÂ aÂ randomÂ numberÂ fromÂ 0Â toÂ 10:Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {Â Math.floor(Math.random()Â *Â 10)Â +Â 1Â }
Â Â Â Â Â Â Â Â Â Â Â Â </h1>
Â Â Â Â Â Â Â Â </div>
Â Â Â Â );
};
```
You can also extract this functionality into a separate function:
```JSX
functionÂ Example3()Â {
Â Â Â Â constÂ getRandomNumÂ =Â ()Â =>Â Math.floor(Math.random()Â *Â 10)Â +Â 1
Â Â Â Â 
Â Â Â Â returnÂ (
Â Â Â Â Â Â Â Â <divÂ className="heading">
Â Â Â Â Â Â Â Â Â Â Â Â <h1>Here'sÂ aÂ randomÂ numberÂ fromÂ 0Â toÂ 10:Â {Â getRandomNum()Â }</h1>
Â Â Â Â Â Â Â Â </div>
Â Â Â Â );

};
```

----
### Expressions as props
You've already learned a bit about using expressions as props. These can be, among other things, ternary operators, function calls, or some arithmetic operations.

However, you can pass almost any kind of expression as a prop.

For example:

```JSX
const bool = false;

function Example(props) {
    return (
        <h2>The value of the toggleBoolean prop is: {props.toggleBoolean.toString()}</h2>
    );
};

export defaul function App() {
    return (
        <div className="App">
        <Example toggleBoolean={!bool} />
        </div>
        );
};
```
In the example above, youâ€™re using the !bool, that is, the NOT operator, which evaluates to true, since !false is true.

Also, for the toggleBoolean prop to be rendered on the page, youâ€™re converting its boolean value to a string using the JavaScriptâ€™s built-in toString method.Â 

Hereâ€™s an extension of the above code which shows more ways to work with expressions as props in React.

What is happening here is several props are being passed to the Example component, and rendering each of these propsâ€™ values to the screen.
```JSX
constÂ boolÂ =Â false;
constÂ str1Â =Â "just";

functionÂ Example(props)Â {
Â Â Â Â returnÂ (
Â Â Â Â Â Â Â Â <div>
Â Â Â Â Â Â Â Â Â Â Â Â <h2>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â TheÂ valueÂ ofÂ theÂ toggleBooleanÂ propÂ is:{props.toggleBoolean.toString()}
Â Â Â Â Â Â Â Â Â Â Â Â </h2>
Â Â Â Â Â Â Â Â Â Â Â Â <p>TheÂ valueÂ ofÂ theÂ mathÂ propÂ is:Â <em>{props.math}</em></p>
Â Â Â Â Â Â Â Â Â Â Â Â <p>TheÂ valueÂ ofÂ theÂ strÂ propÂ is:Â <em>{props.str}</em></p>
Â Â Â Â Â Â Â Â </div>
Â Â Â Â );
};


exportÂ defaultÂ functionÂ App()Â {
Â Â Â Â returnÂ (
Â Â Â Â Â Â Â Â <divÂ className="App">
Â Â Â Â Â Â Â Â Â Â Â Â <Example
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â toggleBoolean={!bool}
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â math={(10Â +Â 20)Â /Â 3}
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â str={str1Â +Â 'Â anotherÂ 'Â +Â 'string'}
Â Â Â Â Â Â Â Â Â Â Â Â />
Â Â Â Â Â Â Â Â </div>
Â Â Â Â );
};
```
In this improvement to the Example component, three props are being passed to it: toggleBoolean, math, and str. The toggleBoolean is unchanged, and the math prop and the str prop have been added.
The math prop is there to show that you can add arithmetic operators and numbers inside JSX, and it will be evaluated just like it does in plain JavaScript.Â 
The str prop is there to show that you can concatenate strings, as well as strings and variables â€“ which is shown by adding string literals of â€œ another â€ and â€œstringâ€ to the str1 variable.

In summary, just like you can use expressions inside function components, you can also use them as prop values inside JSX elements, when rendering those function components.


----
# Week 2
### Eventful issues
React can work with most of the same events found in HTML, although React handles them differently.
This means that you may encounter unfamiliar errors when you run your event-driven React code.

**Event Errors**
When you work in any programming environment, language, or framework, you are bound to write code that throws errors, for a variety of reasons.
The JavaScript language comes with a built-in error handling syntax, the **try...catch** syntax.
Letâ€™s examine an example of an error in JavaScript:
```JSX
(5).toUpperCase()
```
Obviously, you cannot uppercase a number value, and thus, this throws the following error:
```
UncaughtÂ TypeError:Â 5.toUpperCaseÂ isÂ notÂ aÂ function
```
To handle this TypeError, you can update the code with a try...catch block that instructs the code to continue running after the error is encountered:
```JSX
try {
    (5).toUpperCase();
}
catch(e) {
    console.log('Oops,Â youÂ can'tÂ uppercaseÂ aÂ number.Â 
Â Â Â Â Â Â Â Â TryingÂ toÂ doÂ itÂ resultedÂ inÂ theÂ following', e)
}
```
The try-catch block will output some text in the console:
```
Oops, you can't uppercase a number. Trying to do it resulted in the following TypeError: 5.toUpperCase is not a function**
```
here's an example of a simple error in a React component:
```JSX
function NumBillbooard(props) {
    return (
    <>
    <h1>{prop.num}</h1>
    </>
    )
}
export default NumBillboard;
```
In React, an error in the code, such as the one above, will result in the error overlay showing in the app in the browser.
In this specific example, the error would be:

ReferenceError
prop is not defined
Note: _You can click the X button to close the error overlay._

Since event-handling errors occur after the UI has already been rendered, all you have to do is use the error-handling mechanism that already exists in JavaScript â€“ that is, you just use the try...catch blocks.

----
### Event handling and embedded expressions
In this reading, youâ€™ll learn the different ways to embed expressions in event handlers in React:

-   With an inline anonymous ES5 functionÂ 
-   With an inline, anonymous ES6 function (an arrow function)Â     
-   Using a separate function declarationÂ 
-   Using a separate function expressionÂ 
  

You may find this reading useful as a reference sheet.

For clarity and simplicity: a function will simply console log some words. This will allow you to compare the difference in syntax between these four approaches, while the result of the event handling will always be the same: just some words output to the console.

**Handling events using inline anonymous ES5 functions**

This approach allows you to directly pass in an ES5 function declaration as the onClick event-handling attributeâ€™s value:
```JSX
<button onClick={function() {console.log('a message')}}>
  This is an inline anonymous ES5 function event handler
</button>
```
**Handling events using inline anonymous ES6 functions (arrow functions)**

With this approach, you can directly pass in an ES6 function declaration as the onClick event-handling attributeâ€™s value:
```JSX
<button onClick={() => console.log('another message ğŸ˜‰')}>
AnÂ inlineÂ anonymousÂ ES6Â functionÂ eventÂ handler
</button>

```
**Handling events using separate function declarations**

With this approach, you declare a separate ES5 function declaration, and then you reference its name in the event-handling onClick attribute, as follows:
```JSX
function App() {
    function thirdExample() {
    console.log('a message inside an external function')}
};
   Â returnÂ (
Â Â Â Â Â Â Â Â <divÂ className="thirdExample">
Â Â Â Â Â Â Â Â Â Â Â Â <buttonÂ onClick={thirdExample}>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â usingÂ aÂ separateÂ functionÂ declaration
Â Â Â Â Â Â Â Â Â Â Â Â </button>
Â Â Â Â Â Â Â Â </div>
Â Â Â Â );
};

exportÂ defaultÂ App;
```
This syntax makes sense to be used when your onClick logic is too complex to easily fit into an anonymous function. While this example is not really showing this scenario, imagine a function that has, for example, 20 lines of code, and that needs to be ran when the click event is triggered. This is a perfect use-case for a separate function declaration.

**Handling events using separate function expressions**

**Tip**_:_ A way to determine if a function is defined as an expression or a declaration is: if it does not start the line with the keyword function, then itâ€™s an expression.
In the following example, youâ€™re assigning an anonymous ES6 arrow function to a const variable â€“ hence, this is a function expression.
Youâ€™re then using this const variableâ€™s name to handle the onClick event, so this is an example of handling events using a separate function expression.
```JSX
function App() {
    const handleEvent = () => console.log('have a nice day');
    return (
        <div className="fourth">
        <button onClick={handleEvent}>
        Using a separate function Expression
        </button>
        </div>
  
)
}
export default App;
```
The syntax in this example is very common in React. It uses arrow functions, but also allows us to handle situations where our separate function expression spans multiple lines of code.

----

